@ The purpose of [[getline]] is to read in the next line, no matter
how long it is.
We just keep allocating more and more space for the line, until we've
read a whole line or until we run out of space, whichever comes first.
The buffer grows in size exponentially, so this costs roughly the logarithm
of the longest line in extra overhead.
@
Pass in a buffer, return a (possibly) new buffer full of stuff,
or [[NULL]] for end of file.
Initial buffer must be [[NULL]].
<<*>>=
#define START_SIZE 128                  /* initial buffer size */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <assert.h>
#include "columns.h"
#include "errors.h"
#include "getline.h"

<<C functions>>

<<header>>=
char *getline (char *buffer, FILE *fp);
  /* grab a line in the buffer, return a new buffer or NULL for eof */
<<C functions>>=
static buf_size = START_SIZE;

char *getline (char *buffer, FILE *fp) {

    if (buffer==NULL)
        checkptr(buffer = (char *) malloc (buf_size));
    
    buffer=fgets(buffer, buf_size, fp);
    if (buffer==NULL) return buffer; /* end of file */
    while (buffer[strlen(buffer)-1] != '\n') { /* failed to get whole line */
        buf_size *= 2;
        checkptr(buffer = realloc(buffer, buf_size));
        if (fgets(buffer+strlen(buffer),buf_size-strlen(buffer),fp)==NULL)
            return buffer; /* end of file */
    }
    return buffer;
}
@
In a weak moment I decided to combine the functions of [[getline]]
and the Unix program expand(1).
Then I repented, so this code has never been tested.
<<header junk>>=
char *getline_untabify (char *buffer, FILE *fp);
  /* like getline but expands tabs according to TABSIZE */
  /* NEVER TESTED!!!!! */
<<junk>>=
char *getline_untabify (char *buffer, FILE *fp) {

    if ((buf=getline(buffer,fp))==NULL) return NULL;
    while (columnwidth(buf) > buf_size - 1) buf_size *= 2;
    checkptr(buffer = malloc(buf_size));
    s  = buf; t = buffer; width=0;
    while (*s)
        if (*s=='\t') {
            do {
                *t++ = ' '; width++;
            } while (width % TABSIZE != 0);
            s++;
        } else {
            *t++ = *s++; width++;
        }
    *t='\0';
    free(buf);
    return buffer;
}
