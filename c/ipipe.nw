% -*- mode: Noweb; noweb-code-mode: c-mode -*-

\ifx\chapter\undefined\let\chapter=\section\fi

\chapter {Noweb internal pipeline}

This is the design of the Noweb internal pipeline, which will be a
series of program stages passing binary data to and from each other
using the unbounded NowebBuffer.  This pipeline structure will pass
ASCII information to and from the external pipeline as well.

\section {Interface}

A pipeline is a \emph{source}, followed by zero or more
\emph{filters}, followed by a sink.
The original version of this interface used different static types for
sources, filters, and sinks, but this organization caused much
functionality to be implemented in triplicate.
After seeing the code, I~decided it was better to eliminate the
redundancy even though it meant giving up static type checking.
Accordingly, I~use a single C type---the \emph{stage}---to represent
sources, filters, sinks, and pipelines.
A source is a stage that ignores its input buffer, and a sink is a
stage that writes nothing to its output buffer.
All other stages are filters.
<<ipipe.h>>=
#ifndef IPIPE_H
#define IPIPE_H

#include "nwbuffer.h"

typedef struct IPipe_stage *IPipe_T, *IPipe_Source, *IPipe_Filter, *IPipe_Sink;

<<exported functions and values>>
#endif
@ 
We create a stage by providing a suitable function.
[[XPipe_connect]] performs all connections:
\newcommand\source{\mathit{source}}
\newcommand\sink{\mathit{sink}}
\newcommand\filter{\mathit{filter}}
\newcommand\con{\mathbin{\cdot}}
\begin{eqnarray*}
\source \con \filter &=& \source \\
\source \con \sink   &=& \mathit{pipeline} \\
\filter \con \filter &=& \filter \\
\filter \con \sink   &=& \sink \\
\end{eqnarray*}
This example should suggest why distinct static types were deemed
undesirable. 
<<exported functions and values>>=
extern IPipe_T IPipe_stage(int (*stage)(void*, NowebBuffer, NowebBuffer),
			       void* arg);
extern IPipe_T IPipe_connect(IPipe_T, IPipe_T);
@ 
We provide an identity filter $\mathit{id}$; it is both a left and
right identity for~$\con$.
<<exported functions and values>>=
extern IPipe_Filter IPipe_identity;
@ 
Once completed, a pipeline may be executed or freed from memory.
<<exported functions and values>>=
extern int    IPipe_run (IPipe_T pipe, NowebBuffer in, NowebBuffer out);
extern void   IPipe_free(IPipe_T *pipe);
@ 
\section{Implementation}
Here's what the implementation looks like.
<<ipipe.c>>=
#include "ipipe.h"
#include "nwbuffer.h"
#include <mem.h>

<<type definitions>>
<<functions>>
@ 
The basic data type, stage, is just a disjoint union.
<<type definitions>>=
struct IPipe_stage {
  int isPair;
  union {
    struct {
      IPipe_T left, right;
    } pair;
    struct {
      int (*stage)(void*, NowebBuffer, NowebBuffer);
      void* arg;
    } leaf;
  } u;
};
@ 
The create functions simply allocate space for the particular type and set
the appropriate data members equal to the parameters.
<<functions>>=
IPipe_T IPipe_stage(int (*stage)(void*, NowebBuffer, NowebBuffer), void* arg) {
  IPipe_T p = ALLOC(sizeof(*p));
  p->isPair = 0;
  p->u.leaf.stage = stage;
  p->u.leaf.arg = arg;
  return p;
}
<<functions>>=
IPipe_T IPipe_connect(IPipe_T l, IPipe_T r) {
  IPipe_T p = ALLOC(sizeof(*p));
  p->isPair = 1;
  p->u.pair.left  = l;
  p->u.pair.right = r;
  return p;
}
@ 
The pipeline is executed by walking down the left side of the tree until a leaf
is reached, executing that function and placing results into the buffer at that
leaf, then executing the next leaf to the right, and so on until all leaf
functions are executed.
<<functions>>=
int IPipe_run(IPipe_T p, NowebBuffer in, NowebBuffer out) {
  if (p->isPair) {
    NowebBuffer pipe = NowebBuffer_create();
    int rc = IPipe_run(p->u.pair.left, in, pipe) |
             IPipe_run(p->u.pair.right, pipe, out);
    NowebBuffer_free(&pipe);
    return rc;
  } else
    return p->u.leaf.stage(p->u.leaf.arg, in, out);
}
@ 
Freeing means walking the tree.
<<functions>>=
void IPipe_free(IPipe_T *pp) {
  if ((*pp)->isPair) {
    IPipe_free(&(*pp)->u.pair.left);
    IPipe_free(&(*pp)->u.pair.right);
  }
  FREE(pp);
  *pp = (IPipe_T)0;
}
<<*>>=
<<ipipe.c>>
<<header>>=
<<ipipe.h>>
@
