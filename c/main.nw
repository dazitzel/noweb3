% -*- mode: Noweb; noweb-code-mode: c-mode -*-
% Copyright 1991 by Norman Ramsey.  All rights reserved.
% See file COPYRIGHT for more information.
\section{Tangling}
\subsection{Main program}
<<*>>=
static char rcsid[] = "$Id$";
static char rcsname[] = "$Name$";
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include "nwbuffer.h"
#include "cargs.h"
#include "notangle.h"
#include "errors.h"
#include "columns.h"
#include "modules.h"
#include "modtrees.h"

@ 
<<hackers: subsubsections for internal sinks>>=
\subsubsection{The sink \texttt{Stages.nt}}

The \texttt{Stages.nt} sink (back end) implements tangling.
By  all
uses to their definitions, 
it extracts the program defined by one or more chunks named in
arguments,
and it writes that program on standard
output.
Its arbitrary argument is a list of strings representing these options:
\begin{quote}
\begin{tabularx}{\linewidth}{lX}
\tt -t&Turn off expansion of tabs.\\
\tt -t$n$&Expand tabs on $n$-column boundaries.\\
\tt -R{\rmfamily\textit{name}}&Expand the code chunk named \textit{name}.\\
\tt -L{\rmfamily\textit{format}}&Use \textit{format} as the format string
        to emit line-number information.
\end{tabularx}
\end{quote}
See the man page for {\tt notangle} for details on the meanings of
these options and on the expansion performed by \texttt{Stages.nt}.
@
The main program makes one pass through the arguments, using options
to set global state, and counting any roots it sees.
It then makes a second pass to emit all the roots, or if there are no
roots on the command line, it emits the module (chunk) named [[<<*>>]].
<<*>>=
int notangle_sink(void *arg, NowebBuffer in, NowebBuffer out /* unused */) {
    CArgs args = arg;
    int argc = args->argc;
    char **argv = args->argv;
    char *locformat = "";
    char *Clocformat = "#line %L \"%F\"%N";
    int root_options_seen = 0;
    int i;

    tabsize = 0;  /* default for nt is not to use tabs */
    progname = argv[0];
    finalstage = 1;

    for (i=1; i<argc; i++) {
        <<process argument [[i]]---first pass>>
    }

    read_defs(in);	             /* read all the definitions */
    if (errorrc) return errorrc;
    apply_each_module(remove_final_newline); /* pretty up the module texts */
    if (root_options_seen == 0)
      emit_module_named(stdout, "*", locformat);
    else
      for (i=1; i<argc; i++) 
        if (argv[i][0] == '-' && argv[i][1] == 'R')
	  emit_module_named(stdout, argv[i]+2, locformat);

    (void) rcsname; (void) rcsid;   /* slay warning */
    return errorrc;
}
@
<<process argument [[i]]---first pass>>=
if (*argv[i]=='-') {
    <<handle option in argument [[i]]>>
} else {
    <<handle argument in argument [[i]]>>
}
@
The following options are good on the command line:
\begin{fields}
-Rname&         make name the name of the root module. 
                Default is [[@<<*@>>]].\\
-L[format]&     Use the given format to write {\tt\#line} numbers.
                If -L is given alone, use ANSI C format.
                If not given, write no {\tt\#line} numbers.\\
-t[tabsize]& Fiddle with tabs
\end{fields}
<<handle option in argument [[i]]>>=
    switch (argv[i][1]) {
        case 't': /* set tab size or turn off */
            if (isdigit(argv[i][2]))
                tabsize = atoi(argv[i]+2);
            else if (argv[i][2]==0)
                tabsize = 0;            /* no tabs */
            else 
                errormsg(Error, "%s: ill-formed option %s\n", argv[0], argv[i]);
            break;          
        case 'R': /* change name of root module */
            root_options_seen++;
            break;
        case 'L': /* have a #line number format */
            locformat = argv[i]+2;
            if (!*locformat) locformat = Clocformat;
            break;
        default:
            errormsg(Warning, "Ignoring unknown option -%s", argv[i]);
     }
@
<<handle argument in argument [[i]]>>=
errormsg(Warning,
    "I can't handle arguments yet, so I'll just ignore `%s'",argv[i]);

