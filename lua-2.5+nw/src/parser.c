#ifndef lint
static const char luaY_sccsid[] = "@(#)yaccpar	1.9 (Berkeley) 02/21/93";
#endif

#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 9
#define YYPATCH 20100610

#define YYEMPTY        (-1)
#define luaY_clearin      (luaY_char = YYEMPTY)
#define luaY_errok        (luaY_errflag = 0)
#define YYRECOVERING() (luaY_errflag != 0)

#define YYPREFIX "luaY_"

#define YYPURE 0

#line 2 "lua.stx"

char *rcs_luastx = "$Id$";

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "luadebug.h"
#include "mem.h"
#include "lex.h"
#include "opcode.h"
#include "hash.h"
#include "inout.h"
#include "tree.h"
#include "table.h"
#include "lua.h"
#include "func.h"

/* to avoid warnings generated by yacc */
int luaY_parse (void);
#undef malloc
#undef realloc
#define malloc luaI_malloc
#define realloc luaI_realloc
#define free luaI_free

#ifndef LISTING
#define LISTING 0
#endif

#ifndef CODE_BLOCK
#define CODE_BLOCK 256
#endif
static int   maxcode;
static int   maxmain;
static int   maxcurr;
static Byte  *funcCode = NULL;
static Byte **initcode;
static Byte  *basepc;
static int   maincode;
static int   pc;


#define MAXVAR 32
static Long    varbuffer[MAXVAR];    /* variables in an assignment list;
				it's long to store negative Word values */
static int     nvarbuffer=0;	     /* number of variables at a list */

#define MAXLOCALS 32
static TaggedString *localvar[MAXLOCALS];  /* store local variable names */
static int     nlocalvar=0;	     /* number of local variables */

#define MAXFIELDS FIELDS_PER_FLUSH*2
static Word    fields[MAXFIELDS];     /* fieldnames to be flushed */
static int     nfields=0;

int lua_debug = 0;

/* Internal functions */

static void luaY_error (char *s)
{
  luaI_syntaxerror(s);
}

static void check_space (int i)
{
  if (pc+i>maxcurr-1) {  /* 1 byte free to code HALT of main code */
	int adjust = (basepc == *initcode);
    maxcurr = growvector(&basepc, maxcurr, Byte, codeEM, MAX_INT);
	if (adjust) {
#if 0
      char *token = luaI_buffer(1);
      if (token[0] == 0)
        token = "<eof>";
	  fprintf(stderr,
         "no: Adjusted code vector\n> last token read: \"%s\" at line %d in file %s\n",
              token, lua_linenumber, lua_parsedfile);
      fprintf(stderr, "   old vector = %p; new vector = %p\n",
              (void *) *initcode, (void *)basepc);
#endif
	  *initcode = basepc; /* bugfix: don't let *initcode get stale */
    }
  }
}

static void code_byte (Byte c)
{
 check_space(1);
 basepc[pc++] = c;
}

static void code_word (Word n)
{
  check_space(sizeof(Word));
  memcpy(basepc+pc, &n, sizeof(Word));
  pc += sizeof(Word);
}

static void code_float (real n)
{
  check_space(sizeof(real));
  memcpy(basepc+pc, &n, sizeof(real));
  pc += sizeof(real);
}

static void code_code (TFunc *tf)
{
  check_space(sizeof(TFunc *));
  memcpy(basepc+pc, &tf, sizeof(TFunc *));
  pc += sizeof(TFunc *);
}

static void code_word_at (Byte *p, int n)
{
  Word w = n;
  if (w != n)
    luaY_error("block too big");
  memcpy(p, &w, sizeof(Word));
}

static void push_field (Word name)
{
  if (nfields < MAXFIELDS)
    fields[nfields++] = name;
  else
   luaY_error ("too many fields in nested constructors");
}

static void flush_record (int n)
{
  int i;
  if (n == 0) return;
  code_byte(STORERECORD);
  code_byte(n);
  for (i=0; i<n; i++)
    code_word(fields[--nfields]);
}

static void flush_list (int m, int n)
{
  if (n == 0) return;
  if (m == 0)
    code_byte(STORELIST0); 
  else
  if (m < 255)
  {
    code_byte(STORELIST);
    code_byte(m);
  }
  else
   luaY_error ("list constructor too long");
  code_byte(n);
}

static void store_localvar (TaggedString *name, int n)
{
 if (nlocalvar+n < MAXLOCALS)
  localvar[nlocalvar+n] = name;
 else
  luaY_error ("too many local variables");
 if (lua_debug)
   luaI_registerlocalvar(name, lua_linenumber);
}

static void add_localvar (TaggedString *name)
{
  store_localvar(name, 0);
  nlocalvar++;
}

static void add_varbuffer (Long var)
{
 if (nvarbuffer < MAXVAR)
  varbuffer[nvarbuffer++] = var;
 else
  luaY_error ("variable buffer overflow");
}

static void code_number (float f)
{ 
  Word i = (Word)f;
  if (f == (float)i)  /* f has an (short) integer value */
  {
   if (i <= 2) code_byte(PUSH0 + i);
   else if (i <= 255)
   {
    code_byte(PUSHBYTE);
    code_byte(i);
   }
   else
   {
    code_byte(PUSHWORD);
    code_word(i);
   }
  }
  else
  {
   code_byte(PUSHFLOAT);
   code_float(f);
  }
}

/*
** Search a local name and if find return its index. If do not find return -1
*/
static int lua_localname (TaggedString *n)
{
 int i;
 for (i=nlocalvar-1; i >= 0; i--)
  if (n == localvar[i]) return i;	/* local var */
 return -1;		        /* global var */
}

/*
** Push a variable given a number. If number is positive, push global variable
** indexed by (number -1). If negative, push local indexed by ABS(number)-1.
** Otherwise, if zero, push indexed variable (record).
*/
static void lua_pushvar (Long number)
{ 
 if (number > 0)	/* global var */
 {
  code_byte(PUSHGLOBAL);
  code_word(number-1);
 }
 else if (number < 0)	/* local var */
 {
  number = (-number) - 1;
  if (number < 10) code_byte(PUSHLOCAL0 + number);
  else
  {
   code_byte(PUSHLOCAL);
   code_byte(number);
  }
 }
 else
 {
  code_byte(PUSHINDEXED);
 }
}

static void lua_codeadjust (int n)
{
 if (n+nlocalvar == 0)
   code_byte(ADJUST0);
 else
 {
   code_byte(ADJUST);
   code_byte(n+nlocalvar);
 }
}

static void change2main (void)
{
  /* (re)store main values */
  pc=maincode; basepc=*initcode; maxcurr=maxmain;
  nlocalvar=0;
}

static void savemain (void)
{
  /* save main values */
  maincode=pc; *initcode=basepc; maxmain=maxcurr;
}

static void init_func (void)
{
  if (funcCode == NULL)	/* first function */
  {
   funcCode = newvector(CODE_BLOCK, Byte);
   maxcode = CODE_BLOCK;
  }
  savemain();  /* save main values */
  /* set func values */
  pc=0; basepc=funcCode; maxcurr=maxcode; 
  nlocalvar = 0;
  luaI_codedebugline(lua_linenumber);
}

static void codereturn (void)
{
  if (nlocalvar == 0)
    code_byte(RETCODE0);
  else
  {
    code_byte(RETCODE);
    code_byte(nlocalvar);
  }
}

void luaI_codedebugline (int line)
{
  static int lastline = 0;
  if (lua_debug && line != lastline)
  {
    code_byte(SETLINE);
    code_word(line);
    lastline = line;
  }
}

static int adjust_functioncall (Long exp, int i)
{
  if (exp <= 0)
    return -exp; /* exp is -list length */
  else
  {
    int temp = basepc[exp];
    basepc[exp] = i;
    return temp+i;
  }
}

static void adjust_mult_assign (int vars, Long exps, int temps)
{
  if (exps > 0)
  { /* must correct function call */
    int diff = vars - basepc[exps];
    if (diff >= 0)
      adjust_functioncall(exps, diff);
    else
    {
      adjust_functioncall(exps, 0);
      lua_codeadjust(temps);
    }
  }
  else if (vars != -exps)
    lua_codeadjust(temps);
}

static int close_parlist (int dots)
{
  if (!dots)
    lua_codeadjust(0);
  else
  {
    code_byte(VARARGS);
    code_byte(nlocalvar);
    add_localvar(luaI_createfixedstring("arg"));
  }
  return lua_linenumber;
}

static void storesinglevar (Long v)
{
 if (v > 0)		/* global var */
 {
   code_byte(STOREGLOBAL);
   code_word(v-1);
 }
 else if (v < 0)      /* local var */
 {
   int number = (-v) - 1;
   if (number < 10) code_byte(STORELOCAL0 + number);
   else
   {
     code_byte(STORELOCAL);
     code_byte(number);
   }
 }
 else 
   code_byte(STOREINDEXED0);
}

static void lua_codestore (int i)
{
 if (varbuffer[i] != 0)  /* global or local var */
  storesinglevar(varbuffer[i]);
 else				  /* indexed var */
 {
  int j;
  int upper=0;     	/* number of indexed variables upper */
  int param;		/* number of itens until indexed expression */
  for (j=i+1; j <nvarbuffer; j++)
   if (varbuffer[j] == 0) upper++;
  param = upper*2 + i;
  if (param == 0)
   code_byte(STOREINDEXED0);
  else
  {
   code_byte(STOREINDEXED);
   code_byte(param);
  }
 }
}

static void codeIf (Long thenAdd, Long elseAdd)
{
  Long elseinit = elseAdd+sizeof(Word)+1;
  if (pc == elseinit)		/* no else */
  {
    pc -= sizeof(Word)+1;
    elseinit = pc;
  }
  else
  {
    basepc[elseAdd] = JMP;
    code_word_at(basepc+elseAdd+1, pc-elseinit);
  }
  basepc[thenAdd] = IFFJMP;
  code_word_at(basepc+thenAdd+1,elseinit-(thenAdd+sizeof(Word)+1));
}

static void codeIfEqJmp(Long label_address, Long target) {
  /*assert(target >= label_address + 2);*/
  code_word_at(basepc+label_address,target-(label_address+2));
}

/*
** Parse LUA code.
*/
void lua_parse (TFunc *tf)
{
 initcode = &(tf->code);
 *initcode = newvector(CODE_BLOCK, Byte);
 maincode = 0; 
 maxmain = CODE_BLOCK;
 change2main();
 if (luaY_parse ()) lua_error("parse error");
 savemain();
 (*initcode)[maincode++] = RETCODE0;
 tf->size = maincode;
#if LISTING
{ static void PrintCode (Byte *c, Byte *end);
 PrintCode(*initcode,*initcode+maincode); }
#endif
}


#line 435 "lua.stx"
typedef union 
{
 int   vInt;
 float vFloat;
 char *pChar;
 Word  vWord;
 Long  vLong;
 TFunc *pFunc;
 TaggedString *pTStr;
} YYSTYPE;
#line 461 "y.tab.c"
/* compatibility with bison */
#ifdef YYPARSE_PARAM
/* compatibility with FreeBSD */
# ifdef YYPARSE_PARAM_TYPE
#  define YYPARSE_DECL() luaY_parse(YYPARSE_PARAM_TYPE YYPARSE_PARAM)
# else
#  define YYPARSE_DECL() luaY_parse(void *YYPARSE_PARAM)
# endif
#else
# define YYPARSE_DECL() luaY_parse(void)
#endif

/* Parameters sent to lex. */
#ifdef YYLEX_PARAM
# define YYLEX_DECL() luaY_lex(void *YYLEX_PARAM)
# define YYLEX luaY_lex(YYLEX_PARAM)
#else
# define YYLEX_DECL() luaY_lex(void)
# define YYLEX luaY_lex()
#endif

extern int YYPARSE_DECL();
extern int YYLEX_DECL();

#define WRONGTOKEN 257
#define NIL 258
#define IF 259
#define THEN 260
#define ELSE 261
#define ELSEIF 262
#define WHILE 263
#define DO 264
#define REPEAT 265
#define UNTIL 266
#define CASE 267
#define GLOBMATCH 268
#define OF 269
#define END 270
#define RETURN 271
#define LOCAL 272
#define FUNCTION 273
#define DOTS 274
#define ARROW 275
#define NUMBER 276
#define STRING 277
#define NAME 278
#define AND 279
#define OR 280
#define EQ 281
#define NE 282
#define LE 283
#define GE 284
#define CONC 285
#define UNARY 286
#define NOT 287
#define YYERRCODE 256
static const short luaY_lhs[] = {                           -1,
    0,   28,   28,   28,   32,   26,   26,   27,   35,   35,
   31,   31,   30,   30,   30,   40,   30,   41,   30,   30,
   30,   30,   37,   37,   37,   42,   38,   43,   38,   38,
   44,    4,   45,   46,    4,   47,   39,   48,   39,   39,
   49,    5,   50,   51,    5,   52,   34,   29,   29,    1,
    2,    3,   36,    9,    9,    9,    9,    9,    9,    9,
    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
    9,    9,    9,    9,   54,    9,   55,    9,   56,   53,
    8,   12,   12,   11,   11,    6,    6,    7,   57,    7,
   21,   21,   22,   22,   23,   23,   58,   13,   13,   18,
   18,   59,   59,   16,   16,   17,   17,   60,   19,   19,
   20,   20,   10,   10,   24,   24,   24,   25,   33,   14,
   14,   15,   15,
};
static const short luaY_len[] = {                            2,
    2,    0,    3,    2,    3,    1,    3,    5,    0,    3,
    0,    1,    8,    5,    5,    0,    8,    0,    6,    3,
    1,    3,    0,    2,    7,    0,    3,    0,    4,    0,
    0,    5,    0,    0,    8,    0,    3,    0,    4,    0,
    0,    5,    0,    0,    8,    0,    3,    0,    3,    0,
    0,    0,    1,    3,    3,    3,    3,    3,    3,    3,
    3,    3,    3,    3,    3,    3,    2,    1,    1,    1,
    1,    1,    1,    2,    0,    5,    0,    5,    0,    4,
    2,    1,    3,    3,    1,    0,    1,    1,    0,    4,
    0,    1,    1,    3,    1,    1,    0,    3,    2,    0,
    2,    0,    1,    0,    2,    1,    3,    3,    0,    2,
    1,    3,    1,    3,    1,    4,    3,    1,    1,    1,
    3,    0,    2,
};
static const short luaY_defred[] = {                         2,
    0,    0,    0,   16,   18,    0,    0,    0,    0,    0,
  118,   21,    0,    0,    0,  115,    1,    0,    4,    0,
   72,   70,   71,    0,    0,    0,   73,   53,  119,    0,
    0,   68,    0,    0,   46,    0,    0,    0,    0,    0,
    0,  120,    0,    0,    0,    0,    0,    0,    0,   81,
   85,   12,    3,    0,    0,    0,    0,    0,    0,   50,
   50,   50,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    9,    0,    0,
   49,   89,    0,    0,   22,    0,    5,    0,    0,    0,
    0,    0,   83,    0,  117,   54,   46,   75,   77,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,   97,    0,    0,  106,   50,    0,
    0,    0,   26,    0,    0,   36,    0,    0,    0,  121,
   96,   95,    0,    0,   93,    7,   84,  116,   50,    0,
    0,    0,   80,    0,   99,    0,    0,  110,   46,    0,
   47,    0,   28,    0,   14,   38,    0,   15,    0,   46,
    0,    0,    0,    0,    0,    0,  107,    0,   98,    0,
   50,   19,   10,   46,   27,    0,   46,   37,    0,    0,
   94,   46,    0,    0,  101,    0,    0,   29,    0,   50,
   39,    0,   50,    8,   24,    0,   13,  105,   17,   31,
    0,   41,    0,   50,    0,   34,    0,   44,   46,   32,
   46,   42,   46,   50,   50,   50,    0,    0,    0,   25,
   35,   45,
};
static const short luaY_dgoto[] = {                          1,
   97,  189,  192,  175,  178,   38,   39,   27,   28,   13,
   50,   14,  113,   43,   85,  185,  114,  169,  115,  116,
  133,  134,  135,   29,   16,   45,   87,    2,   17,   18,
   53,   19,   30,   77,  121,   41,  184,  124,  127,   34,
   35,  154,  174,  205,  190,  211,  157,  177,  207,  193,
  213,   78,   32,  140,  141,   33,  128,  146,  145,  118,
};
static const short luaY_sindex[] = {                         0,
    0,  226,  -37,    0,    0,  -37,  -37,  -37, -247, -242,
    0,    0,  -12,   -1,    0,    0,    0,   -5,    0,  105,
    0,    0,    0,  -37,  -37,  -37,    0,    0,    0,  105,
  938,    0,  -65,  -37,    0,  142,  912,   -5,   18,    0,
 1264,    0,   -4,    0,   34,  119,  -37, -242,  -37,    0,
    0,    0,    0, -210,  -37, -202,   26,   26,   71,    0,
    0,    0,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,
  -37,  -37,  -37,  -37,  -34, 1273, -143,    0, -114, -112,
    0,    0,  -37, -151,    0, -227,    0, -139,   18,    0,
   91,   94,    0, 1236,    0,    0,    0,    0,    0,  -38,
  -38,  -38,  -38,  -38,  -38,   35,  -13,  -13,   26,   26,
   26,   79,   19,  102,    0,  106, 1264,    0,    0,  -37,
  592, -116,    0, -106, -104,    0, -101,  -37,   18,    0,
    0,    0,  133,  137,    0,    0,    0,    0,    0,  -37,
  -37,  -37,    0,  -95,    0,  129,  -37,    0,    0, 1264,
    0,   -5,    0,  -37,    0,    0,  -37,    0,    0,    0,
 -227, -152,  -27,  -27, 1264,   79,    0,  -95,    0, 1264,
    0,    0,    0,    0,    0, 1264,    0,    0, 1264,  -80,
    0,    0,  -37,  -79,    0,  102,  -78,    0,  150,    0,
    0,  151,    0,    0,    0, 1304,    0,    0,    0,    0,
  -77,    0,  -76,    0,  -37,    0,  -37,    0,    0,    0,
    0,    0,    0,    0,    0,    0, -152, -114, -112,    0,
    0,    0,
};
static const short luaY_rindex[] = {                         0,
    0,  200,   78,    0,    0,   78,   78,  700,    0,    0,
    0,    0,    0,   78,   45,    0,    0,  197,    0,  -15,
    0,    0,    0,   78,   78,   78,    0,    0,    0,    1,
    0,    0,    0,   78,    0,    0,    0,  101,  894,  510,
    0,    0,   83,   76,    0,    0,   78,    0,  -19,    0,
    0,    0,    0,    0,   78,    0,   28,   55, 1295,    0,
    0,    0,   78,   78,   78,   78,   78,   78,   78,   78,
   78,   78,   78,   78,    5,    0,    0,    0,  -67,  -62,
    0,    0,   78,    0,    0,  164,    0,    0, 1212,  132,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  785,
  812,  839,  867, 1113, 1141,  472,  414,  443,  113,  358,
  387,  482,    0,   84,    0,  -33,   -7,    0,    0,   78,
 -100,    0,    0,    0,    0,    0,    0,   78, 1235,    0,
    0,    0,    0,  170,    0,    0,    0,    0,    0,   78,
   78,   78,    0,   87,    0,   88,   20,    0,    0, 1263,
    0,  316,    0,   78,    0,    0,   78,    0,  758,    0,
    0,  -56, 1167, 1189,  -14,    0,    0,   90,    0,   -6,
    0,    0,    0,    0,    0,  -44,    0,    0,  -42,    0,
    0,    0,   78,    0,    0,   84,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,   78,    0,   78,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  -56,  -67,  -62,    0,
    0,    0,
};
static const short luaY_gindex[] = {                         0,
  800,    0,    0,   13,    9,  168,    3,   12,   58,    0,
    0,    0,    0,    0,    0,    0,   51,    0,    0,    0,
    0,    0,   59,   11,    0,    0,    0,    0,  107,  108,
  -21,    0,   17, 1090,    0, 1566,   10,    4,    7,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  216,    0,    0,    0,    0,    0,  -93,  104,
};
#define YYTABLESIZE 1773
static const short luaY_table[] = {                         51,
   69,   52,   26,   72,   70,   26,   71,   24,   73,  123,
   24,  126,   15,   12,   72,   70,   81,   71,   20,   73,
   44,   86,  148,   48,   82,  102,   46,   67,   72,  108,
   42,   48,   66,   73,   65,   11,  111,  112,   49,   84,
   82,   69,   69,   69,   69,   69,  131,   69,   47,   89,
  132,  111,  112,   52,   74,   74,   83,   75,   90,   69,
   69,   82,   69,  109,   91,   40,   74,   93,   67,   67,
   67,   67,   67,   86,   67,   95,   72,   70,  103,   71,
   74,   73,  122,   59,  119,  129,   67,   67,  113,   67,
  119,  102,  198,   69,   69,   74,   74,   74,   74,   74,
   11,   74,  119,   79,   40,  113,   40,   82,  182,  183,
  108,   96,   63,   74,   74,    6,   74,  111,  112,   74,
   67,  119,  120,   82,   69,   69,  130,   79,   74,  109,
  173,   15,   12,  119,  137,  119,   56,   20,  136,  142,
   40,  122,   79,  143,  103,  144,  122,   74,  125,  147,
   56,   67,   67,   63,   63,   63,   63,   63,  153,   63,
   48,   48,   54,  155,   56,   48,  119,  119,  158,   48,
  156,   63,   63,  160,   63,  114,   88,  119,   74,   74,
  161,   55,  166,   72,   70,  159,   71,  168,   73,  194,
  197,  199,  114,  200,  202,   55,   11,  206,  208,   48,
   79,   66,   30,   65,   91,   63,  122,   40,  102,   55,
   92,  103,  100,   23,  104,  212,   92,  210,  186,  181,
   21,  221,  119,   21,   11,  222,  220,  151,  152,   51,
   33,    0,   43,    0,    0,   74,   63,   63,   22,   23,
   11,   22,   23,  112,    0,    0,   69,  167,    0,   25,
    0,    0,   25,   63,   64,   67,   68,   69,    0,   69,
   69,   69,   69,   69,   69,   69,   69,   69,   69,   69,
   69,   69,   69,   69,    0,   69,    0,    0,   69,   69,
   69,   69,   69,   69,   69,   69,   67,   67,   67,   67,
   67,   67,   67,   67,   67,   67,   67,   67,   67,   67,
   67,    0,   67,    0,    0,   67,   67,   67,   67,   67,
   67,   67,   67,   74,   74,   74,   74,   74,   74,   74,
   74,   74,   74,   74,   74,   74,   74,   74,    0,   74,
    0,    0,   74,   74,   74,   74,   74,   74,   74,   74,
    0,  122,    0,  122,  122,  122,    0,  122,  122,  122,
  122,    0,  122,  122,  122,  122,    0,   64,    0,    0,
  122,   11,   11,    0,    0,    0,   11,    0,    0,    0,
   11,   63,   63,   63,   63,   63,   63,   63,   63,   63,
   63,   63,   63,   63,   63,   63,   65,   63,    0,    0,
   63,   63,   63,   63,   63,   63,   63,   63,   64,   64,
   64,   64,   64,    0,   64,    0,    0,    0,    0,    0,
   79,    0,    0,   61,    0,    0,   64,   64,    0,   64,
   61,   62,   63,   64,   67,   68,   69,   65,   65,   65,
   65,   65,    0,   65,    0,    0,    0,    0,    0,   11,
    0,    0,   62,    0,    0,   65,   65,    0,   65,    0,
   64,    0,    0,    0,   61,   11,   61,   61,   61,   11,
    0,   11,    0,   11,   11,    0,    0,   11,   11,   11,
    0,   66,   61,   61,   11,   61,    0,    0,    0,   65,
    0,   64,   64,   62,    3,   62,   62,   62,    4,    0,
    5,    0,    6,    7,    0,    0,    8,    9,   10,    0,
    0,   62,   62,   11,   62,    0,   61,    0,    0,   88,
   65,   65,   66,    0,    0,   66,    0,    0,    0,    0,
    0,  118,    0,  118,  118,  118,  118,  118,  118,    0,
   66,   66,    0,   66,    0,   62,    0,   61,   61,  118,
  118,  118,    0,  118,    0,    0,    0,    0,    0,    0,
   88,   53,   53,   88,   53,    0,   53,    0,    0,    0,
    0,    0,    0,    0,   66,    0,   62,   62,   88,   53,
    0,   53,  118,    0,   11,  118,   11,   11,   11,    0,
   11,   11,   11,   11,    0,   11,   11,   11,    0,    0,
    0,    0,    0,   11,    0,   66,   66,    0,    0,    0,
    0,    0,    0,   53,  118,    0,  118,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   64,   64,   64,   64,
   64,   64,   64,   64,   64,   64,   64,   64,   64,   64,
   64,    0,   64,   88,    0,   64,   64,   64,   64,   64,
   64,   64,   64,    0,    0,   65,   65,   65,   65,   65,
   65,   65,   65,   65,   65,   65,   65,   65,   65,   65,
    0,   65,    0,    0,   65,   65,   65,   65,   65,   65,
   65,   65,   61,   61,   61,   61,   61,   61,   61,   61,
   61,   61,   61,   61,   61,   61,   61,    0,   61,    0,
    0,   61,   61,   61,   61,   61,   61,   61,   61,   86,
    0,   62,   62,   62,   62,   62,   62,   62,   62,   62,
   62,   62,   62,   62,   62,   62,    0,   62,    0,    0,
   62,   62,   62,   62,   62,   62,   62,   62,    0,    0,
   66,   66,   66,   66,   66,   66,   66,   66,   66,   66,
   66,   66,   66,   66,   66,    0,   66,    0,    0,   66,
   66,   66,   66,   66,   66,   66,   66,   90,   86,    0,
  118,  118,  118,  118,  118,  118,  118,    0,   88,    0,
   88,   88,   88,    0,   88,   88,   88,   88,    0,   88,
   88,   88,   88,    0,   55,    0,    0,   88,   53,   53,
   53,   53,   53,   53,   53,    0,    0,    0,   90,   53,
   53,   90,   53,    0,   53,    0,    0,    0,    0,    0,
    0,   58,    0,    0,    0,    0,   90,   53,    0,   53,
    0,    0,   79,   86,    0,   55,    0,    0,   55,    0,
    0,    0,    0,    0,    0,    0,    0,    0,   57,    0,
    0,    0,    0,   55,   55,    0,   55,    0,    0,    0,
    3,   53,   58,    0,    4,   58,    5,    0,    6,    7,
   98,   99,    8,    9,    0,    0,   56,    0,    0,   11,
   58,   58,    0,   58,    0,    0,    0,   55,    0,   57,
    0,   90,   57,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,   87,    0,    0,    0,   57,   57,    0,
   57,    0,    0,    0,   58,    0,    0,   56,   55,   55,
   56,    0,    0,    0,    0,    0,    0,    0,  149,    0,
    0,    0,    0,    0,    0,   56,   56,    0,   56,    0,
    0,   57,    0,    0,   87,   58,   58,    0,  162,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  172,
    0,    0,   87,   72,   70,    0,   71,    0,   73,   56,
   86,   86,   57,   57,    0,   86,    0,    0,    0,   86,
  187,   66,    0,   65,    0,    0,    0,    0,    0,   72,
   70,    0,   71,    0,   73,    0,    0,    0,    0,  201,
   56,   56,  203,    0,    0,    0,    0,   66,    0,   65,
    0,    0,    0,  209,    0,   74,    0,    0,    0,    0,
    0,    0,    0,  217,  218,  219,   90,   87,   90,   90,
   90,    0,   90,   90,   90,   90,    0,   90,   90,   90,
   90,   74,    0,    0,    0,   90,   53,   53,   53,   53,
   53,   53,   53,   55,   55,   55,   55,   55,   55,   55,
   55,   55,   55,   55,   55,   55,   55,   55,    0,   55,
    0,    0,   55,   55,   55,   55,   55,   55,   55,    0,
   58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
   58,   58,   58,   58,   58,    0,   58,    0,    0,   58,
   58,   58,   58,   58,   58,   58,    0,   57,   57,   57,
   57,   57,   57,   57,   57,   57,   57,   57,   57,   57,
   57,   57,   59,   57,    0,    0,   57,   57,   57,   57,
   57,   57,   57,    0,    0,   56,   56,   56,   56,   56,
   56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
   60,   56,    0,    0,   56,   56,   56,   56,   56,   56,
   56,    0,    0,   59,   87,   87,   59,    0,    0,   87,
    0,    0,    0,   87,    0,    0,   76,    0,    0,    0,
    0,   59,   59,    0,   59,    0,    0,    0,    0,    0,
   80,   60,    0,    0,   60,    0,  139,    0,   78,    0,
   61,   62,   63,   64,   67,   68,   69,   60,    0,   60,
   60,    0,   60,    0,    0,   59,    0,   76,    0,    0,
   76,   20,    0,    0,    0,    0,   61,   62,   63,   64,
   67,   68,   69,    0,    0,   76,    0,    0,    0,   78,
    0,    0,   78,   60,  123,    0,   59,   59,  171,    0,
    0,    0,    0,    0,    0,    0,    0,   78,    0,  180,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   76,
    0,    0,   50,  188,   60,   60,  191,    0,    0,    0,
   20,  195,    0,    0,    0,    0,    0,   72,   70,    0,
   71,   78,   73,    0,    0,    0,    0,    0,    0,    0,
   76,   76,    0,  123,    0,   66,    0,   65,  214,    0,
  215,    0,  216,    0,    0,   72,   70,    0,   71,    0,
   73,    0,   78,   78,   72,   70,    0,   71,    0,   73,
    0,   50,    0,   66,    0,   65,    0,    0,  138,   74,
    0,    0,   66,    0,   65,   20,   53,   53,    0,   53,
    0,   53,    0,    0,    0,   72,   70,    0,   71,    0,
   73,    0,    0,    0,   53,    0,   53,   74,  123,    0,
    0,    0,    0,   66,    0,   65,   74,    0,    0,    0,
    0,   59,   59,   59,   59,   59,   59,   59,   59,   59,
   59,   59,   59,   59,   59,   59,   50,   59,   53,    0,
   59,   59,   59,   59,   59,   59,   59,   74,    0,   60,
   60,   60,   60,   60,   60,   60,   60,   60,   60,   60,
   60,   60,   60,   60,    0,   60,    0,    0,   60,   60,
   60,   60,   60,   60,   60,   76,   76,   76,   76,   76,
   76,   76,   76,   76,   76,   76,   76,   76,   76,   76,
    0,   76,    0,    0,   76,   76,   76,   78,   78,   78,
   78,   78,   78,   78,   78,   78,   78,   78,   78,   78,
   78,   78,    0,   78,    0,    0,   78,   78,   78,    0,
   20,    0,   20,   20,   20,    0,   20,   20,   20,   20,
    0,   20,   20,   20,   20,    0,    0,    0,    0,   20,
    0,    0,    0,  123,    0,  123,  123,  123,    0,  123,
  123,  123,  123,    0,  123,  123,  123,  123,    0,    0,
    0,    0,  123,    0,   61,   62,   63,   64,   67,   68,
   69,   50,    0,   50,   50,   50,    0,   50,   50,   50,
   50,    0,   50,   50,   50,   50,  119,    0,    0,    0,
   50,    0,   61,   62,   63,   64,   67,   68,   69,    0,
    0,   61,   62,   63,   64,   67,   68,   69,    0,    0,
    0,    0,    0,  204,    0,    0,    0,    0,   31,    0,
    0,   36,   37,   53,   53,   53,   53,   53,   53,   53,
    0,    0,   61,   62,   63,   64,   67,   68,   69,   57,
   58,    0,    0,    0,    0,    0,    0,    0,    0,   76,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   94,    0,    0,    0,    0,    0,    0,    0,  100,  101,
  102,  103,  104,  105,  106,  107,  108,  109,  110,  111,
  117,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  150,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  163,  164,  165,    0,    0,
    0,    0,  170,    0,    0,    0,    0,    0,    0,  176,
    0,    0,  179,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  196,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  176,    0,  179,
};
static const short luaY_check[] = {                         44,
    0,   44,   40,   42,   43,   40,   45,   45,   47,  124,
   45,  124,    2,    2,   42,   43,   38,   45,    2,   47,
   10,   41,  116,  124,   40,   59,   10,    0,   42,   44,
  278,   44,   60,   47,   62,  278,   44,   44,   40,   44,
   40,   41,   42,   43,   44,   45,  274,   47,   61,   47,
  278,   59,   59,   59,    0,   94,   61,  123,   48,   59,
   60,   44,   62,   59,   48,    8,   94,  278,   41,   42,
   43,   44,   45,   40,   47,  278,   42,   43,   59,   45,
   94,   47,    0,   26,   40,   83,   59,   60,   44,   62,
   46,  125,  186,   93,   94,   41,   42,   43,   44,   45,
    0,   47,   58,  123,   47,   61,   49,  123,  261,  262,
  125,   41,    0,   59,   60,   40,   62,  125,  125,   94,
   93,   46,  266,  123,  124,  125,  278,  123,   94,  125,
  152,  121,  121,   58,   41,   91,   46,  121,  278,   61,
   83,   59,  123,  125,  125,   44,  261,   93,  261,   44,
   46,  124,  125,   41,   42,   43,   44,   45,  275,   47,
  261,  262,   58,  270,   46,  266,   91,  123,  270,  270,
  275,   59,   60,   41,   62,   44,   58,   46,  124,  125,
   44,   91,  278,   42,   43,  128,   45,   59,   47,  270,
  270,  270,   61,   44,   44,   91,    0,  275,  275,    0,
  123,   60,  270,   62,   41,   93,  124,  270,  125,   91,
   41,  125,  125,  270,  125,  207,   49,  205,  168,  161,
  258,  218,   91,  258,  124,  219,  217,  121,  121,   14,
  275,   -1,  275,   -1,   -1,   94,  124,  125,  276,  277,
  278,  276,  277,  278,   -1,   -1,  285,  144,   -1,  287,
   -1,   -1,  287,  281,  282,  283,  284,  285,   -1,  259,
  260,  261,  262,  263,  264,  265,  266,  267,  268,  269,
  270,  271,  272,  273,   -1,  275,   -1,   -1,  278,  279,
  280,  281,  282,  283,  284,  285,  259,  260,  261,  262,
  263,  264,  265,  266,  267,  268,  269,  270,  271,  272,
  273,   -1,  275,   -1,   -1,  278,  279,  280,  281,  282,
  283,  284,  285,  259,  260,  261,  262,  263,  264,  265,
  266,  267,  268,  269,  270,  271,  272,  273,   -1,  275,
   -1,   -1,  278,  279,  280,  281,  282,  283,  284,  285,
   -1,  259,   -1,  261,  262,  263,   -1,  265,  266,  267,
  268,   -1,  270,  271,  272,  273,   -1,    0,   -1,   -1,
  278,  261,  262,   -1,   -1,   -1,  266,   -1,   -1,   -1,
  270,  259,  260,  261,  262,  263,  264,  265,  266,  267,
  268,  269,  270,  271,  272,  273,    0,  275,   -1,   -1,
  278,  279,  280,  281,  282,  283,  284,  285,   41,   42,
   43,   44,   45,   -1,   47,   -1,   -1,   -1,   -1,   -1,
  269,   -1,   -1,    0,   -1,   -1,   59,   60,   -1,   62,
  279,  280,  281,  282,  283,  284,  285,   41,   42,   43,
   44,   45,   -1,   47,   -1,   -1,   -1,   -1,   -1,  124,
   -1,   -1,    0,   -1,   -1,   59,   60,   -1,   62,   -1,
   93,   -1,   -1,   -1,   41,  259,   43,   44,   45,  263,
   -1,  265,   -1,  267,  268,   -1,   -1,  271,  272,  273,
   -1,    0,   59,   60,  278,   62,   -1,   -1,   -1,   93,
   -1,  124,  125,   41,  259,   43,   44,   45,  263,   -1,
  265,   -1,  267,  268,   -1,   -1,  271,  272,  273,   -1,
   -1,   59,   60,  278,   62,   -1,   93,   -1,   -1,    0,
  124,  125,   41,   -1,   -1,   44,   -1,   -1,   -1,   -1,
   -1,   40,   -1,   42,   43,   44,   45,   46,   47,   -1,
   59,   60,   -1,   62,   -1,   93,   -1,  124,  125,   58,
   59,   60,   -1,   62,   -1,   -1,   -1,   -1,   -1,   -1,
   41,   42,   43,   44,   45,   -1,   47,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   93,   -1,  124,  125,   59,   60,
   -1,   62,   91,   -1,  259,   94,  261,  262,  263,   -1,
  265,  266,  267,  268,   -1,  270,  271,  272,   -1,   -1,
   -1,   -1,   -1,  278,   -1,  124,  125,   -1,   -1,   -1,
   -1,   -1,   -1,   94,  123,   -1,  125,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  259,  260,  261,  262,
  263,  264,  265,  266,  267,  268,  269,  270,  271,  272,
  273,   -1,  275,  124,   -1,  278,  279,  280,  281,  282,
  283,  284,  285,   -1,   -1,  259,  260,  261,  262,  263,
  264,  265,  266,  267,  268,  269,  270,  271,  272,  273,
   -1,  275,   -1,   -1,  278,  279,  280,  281,  282,  283,
  284,  285,  259,  260,  261,  262,  263,  264,  265,  266,
  267,  268,  269,  270,  271,  272,  273,   -1,  275,   -1,
   -1,  278,  279,  280,  281,  282,  283,  284,  285,    0,
   -1,  259,  260,  261,  262,  263,  264,  265,  266,  267,
  268,  269,  270,  271,  272,  273,   -1,  275,   -1,   -1,
  278,  279,  280,  281,  282,  283,  284,  285,   -1,   -1,
  259,  260,  261,  262,  263,  264,  265,  266,  267,  268,
  269,  270,  271,  272,  273,   -1,  275,   -1,   -1,  278,
  279,  280,  281,  282,  283,  284,  285,    0,   59,   -1,
  279,  280,  281,  282,  283,  284,  285,   -1,  259,   -1,
  261,  262,  263,   -1,  265,  266,  267,  268,   -1,  270,
  271,  272,  273,   -1,    0,   -1,   -1,  278,  279,  280,
  281,  282,  283,  284,  285,   -1,   -1,   -1,   41,   42,
   43,   44,   45,   -1,   47,   -1,   -1,   -1,   -1,   -1,
   -1,    0,   -1,   -1,   -1,   -1,   59,   60,   -1,   62,
   -1,   -1,  123,  124,   -1,   41,   -1,   -1,   44,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,    0,   -1,
   -1,   -1,   -1,   59,   60,   -1,   62,   -1,   -1,   -1,
  259,   94,   41,   -1,  263,   44,  265,   -1,  267,  268,
   61,   62,  271,  272,   -1,   -1,    0,   -1,   -1,  278,
   59,   60,   -1,   62,   -1,   -1,   -1,   93,   -1,   41,
   -1,  124,   44,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,    0,   -1,   -1,   -1,   59,   60,   -1,
   62,   -1,   -1,   -1,   93,   -1,   -1,   41,  124,  125,
   44,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  119,   -1,
   -1,   -1,   -1,   -1,   -1,   59,   60,   -1,   62,   -1,
   -1,   93,   -1,   -1,   41,  124,  125,   -1,  139,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  150,
   -1,   -1,   59,   42,   43,   -1,   45,   -1,   47,   93,
  261,  262,  124,  125,   -1,  266,   -1,   -1,   -1,  270,
  171,   60,   -1,   62,   -1,   -1,   -1,   -1,   -1,   42,
   43,   -1,   45,   -1,   47,   -1,   -1,   -1,   -1,  190,
  124,  125,  193,   -1,   -1,   -1,   -1,   60,   -1,   62,
   -1,   -1,   -1,  204,   -1,   94,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  214,  215,  216,  259,  124,  261,  262,
  263,   -1,  265,  266,  267,  268,   -1,  270,  271,  272,
  273,   94,   -1,   -1,   -1,  278,  279,  280,  281,  282,
  283,  284,  285,  259,  260,  261,  262,  263,  264,  265,
  266,  267,  268,  269,  270,  271,  272,  273,   -1,  275,
   -1,   -1,  278,  279,  280,  281,  282,  283,  284,   -1,
  259,  260,  261,  262,  263,  264,  265,  266,  267,  268,
  269,  270,  271,  272,  273,   -1,  275,   -1,   -1,  278,
  279,  280,  281,  282,  283,  284,   -1,  259,  260,  261,
  262,  263,  264,  265,  266,  267,  268,  269,  270,  271,
  272,  273,    0,  275,   -1,   -1,  278,  279,  280,  281,
  282,  283,  284,   -1,   -1,  259,  260,  261,  262,  263,
  264,  265,  266,  267,  268,  269,  270,  271,  272,  273,
    0,  275,   -1,   -1,  278,  279,  280,  281,  282,  283,
  284,   -1,   -1,   41,  261,  262,   44,   -1,   -1,  266,
   -1,   -1,   -1,  270,   -1,   -1,    0,   -1,   -1,   -1,
   -1,   59,   60,   -1,   62,   -1,   -1,   -1,   -1,   -1,
  269,   41,   -1,   -1,   44,   -1,   97,   -1,    0,   -1,
  279,  280,  281,  282,  283,  284,  285,  260,   -1,   59,
   60,   -1,   62,   -1,   -1,   93,   -1,   41,   -1,   -1,
   44,    0,   -1,   -1,   -1,   -1,  279,  280,  281,  282,
  283,  284,  285,   -1,   -1,   59,   -1,   -1,   -1,   41,
   -1,   -1,   44,   93,    0,   -1,  124,  125,  149,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   59,   -1,  160,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   93,
   -1,   -1,    0,  174,  124,  125,  177,   -1,   -1,   -1,
   59,  182,   -1,   -1,   -1,   -1,   -1,   42,   43,   -1,
   45,   93,   47,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
  124,  125,   -1,   59,   -1,   60,   -1,   62,  209,   -1,
  211,   -1,  213,   -1,   -1,   42,   43,   -1,   45,   -1,
   47,   -1,  124,  125,   42,   43,   -1,   45,   -1,   47,
   -1,   59,   -1,   60,   -1,   62,   -1,   -1,   93,   94,
   -1,   -1,   60,   -1,   62,  124,   42,   43,   -1,   45,
   -1,   47,   -1,   -1,   -1,   42,   43,   -1,   45,   -1,
   47,   -1,   -1,   -1,   60,   -1,   62,   94,  124,   -1,
   -1,   -1,   -1,   60,   -1,   62,   94,   -1,   -1,   -1,
   -1,  259,  260,  261,  262,  263,  264,  265,  266,  267,
  268,  269,  270,  271,  272,  273,  124,  275,   94,   -1,
  278,  279,  280,  281,  282,  283,  284,   94,   -1,  259,
  260,  261,  262,  263,  264,  265,  266,  267,  268,  269,
  270,  271,  272,  273,   -1,  275,   -1,   -1,  278,  279,
  280,  281,  282,  283,  284,  259,  260,  261,  262,  263,
  264,  265,  266,  267,  268,  269,  270,  271,  272,  273,
   -1,  275,   -1,   -1,  278,  279,  280,  259,  260,  261,
  262,  263,  264,  265,  266,  267,  268,  269,  270,  271,
  272,  273,   -1,  275,   -1,   -1,  278,  279,  280,   -1,
  259,   -1,  261,  262,  263,   -1,  265,  266,  267,  268,
   -1,  270,  271,  272,  273,   -1,   -1,   -1,   -1,  278,
   -1,   -1,   -1,  259,   -1,  261,  262,  263,   -1,  265,
  266,  267,  268,   -1,  270,  271,  272,  273,   -1,   -1,
   -1,   -1,  278,   -1,  279,  280,  281,  282,  283,  284,
  285,  259,   -1,  261,  262,  263,   -1,  265,  266,  267,
  268,   -1,  270,  271,  272,  273,  264,   -1,   -1,   -1,
  278,   -1,  279,  280,  281,  282,  283,  284,  285,   -1,
   -1,  279,  280,  281,  282,  283,  284,  285,   -1,   -1,
   -1,   -1,   -1,  260,   -1,   -1,   -1,   -1,    3,   -1,
   -1,    6,    7,  279,  280,  281,  282,  283,  284,  285,
   -1,   -1,  279,  280,  281,  282,  283,  284,  285,   24,
   25,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   34,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   55,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   63,   64,
   65,   66,   67,   68,   69,   70,   71,   72,   73,   74,
   75,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  120,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  140,  141,  142,   -1,   -1,
   -1,   -1,  147,   -1,   -1,   -1,   -1,   -1,   -1,  154,
   -1,   -1,  157,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  183,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
  205,   -1,  207,
};
#define YYFINAL 1
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#define YYMAXTOKEN 287
#if YYDEBUG
static const char *luaY_name[] = {

"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,"'('","')'","'*'","'+'","','","'-'","'.'","'/'",0,0,0,0,0,0,0,0,0,0,
"':'","';'","'<'","'='","'>'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,"'['",0,"']'","'^'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,"'{'","'|'","'}'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"WRONGTOKEN","NIL","IF","THEN","ELSE",
"ELSEIF","WHILE","DO","REPEAT","UNTIL","CASE","GLOBMATCH","OF","END","RETURN",
"LOCAL","FUNCTION","DOTS","ARROW","NUMBER","STRING","NAME","AND","OR","EQ","NE",
"LE","GE","CONC","UNARY","NOT",
};
static const char *luaY_rule[] = {
"$accept : chunk",
"chunk : chunklist ret",
"chunklist :",
"chunklist : chunklist stat sc",
"chunklist : chunklist function",
"function : FUNCTION funcname body",
"funcname : var",
"funcname : varexp ':' NAME",
"body : '(' parlist ')' block END",
"statlist :",
"statlist : statlist stat sc",
"sc :",
"sc : ';'",
"stat : IF expr1 THEN PrepJump block PrepJump elsepart END",
"stat : CASE expr1 OF case_body END",
"stat : GLOBMATCH expr1 OF glob_body END",
"$$1 :",
"stat : WHILE $$1 expr1 DO PrepJump block PrepJump END",
"$$2 :",
"stat : REPEAT $$2 block UNTIL expr1 PrepJump",
"stat : varlist1 '=' exprlist1",
"stat : functioncall",
"stat : LOCAL localdeclist decinit",
"elsepart :",
"elsepart : ELSE block",
"elsepart : ELSEIF expr1 THEN PrepJump block PrepJump elsepart",
"$$3 :",
"case_body : '|' $$3 tagged_arm_and_body",
"$$4 :",
"case_body : ELSE ARROW $$4 block",
"case_body :",
"$$5 :",
"tagged_arm_and_body : expr1 PrepIfEqJump ',' $$5 tagged_arm_and_body",
"$$6 :",
"$$7 :",
"tagged_arm_and_body : expr1 $$6 PrepJump ARROW $$7 block PrepJump case_body",
"$$8 :",
"glob_body : '|' $$8 glob_arm_and_body",
"$$9 :",
"glob_body : ELSE ARROW $$9 block",
"glob_body :",
"$$10 :",
"glob_arm_and_body : expr1 PrepIfGlobJump ',' $$10 glob_arm_and_body",
"$$11 :",
"$$12 :",
"glob_arm_and_body : expr1 $$11 PrepJump ARROW $$12 block PrepJump glob_body",
"$$13 :",
"block : $$13 statlist ret",
"ret :",
"ret : RETURN exprlist sc",
"PrepJump :",
"PrepIfEqJump :",
"PrepIfGlobJump :",
"expr1 : expr",
"expr : '(' expr ')'",
"expr : expr1 EQ expr1",
"expr : expr1 '<' expr1",
"expr : expr1 '>' expr1",
"expr : expr1 NE expr1",
"expr : expr1 LE expr1",
"expr : expr1 GE expr1",
"expr : expr1 '+' expr1",
"expr : expr1 '-' expr1",
"expr : expr1 '*' expr1",
"expr : expr1 '/' expr1",
"expr : expr1 '^' expr1",
"expr : expr1 CONC expr1",
"expr : '-' expr1",
"expr : table",
"expr : varexp",
"expr : NUMBER",
"expr : STRING",
"expr : NIL",
"expr : functioncall",
"expr : NOT expr1",
"$$14 :",
"expr : expr1 AND PrepJump $$14 expr1",
"$$15 :",
"expr : expr1 OR PrepJump $$15 expr1",
"$$16 :",
"table : $$16 '{' fieldlist '}'",
"functioncall : funcvalue funcParams",
"funcvalue : varexp",
"funcvalue : varexp ':' NAME",
"funcParams : '(' exprlist ')'",
"funcParams : table",
"exprlist :",
"exprlist : exprlist1",
"exprlist1 : expr",
"$$17 :",
"exprlist1 : exprlist1 ',' $$17 expr",
"parlist :",
"parlist : parlist1",
"parlist1 : par",
"parlist1 : parlist1 ',' par",
"par : NAME",
"par : DOTS",
"$$18 :",
"fieldlist : lfieldlist $$18 semicolonpart",
"fieldlist : ffieldlist1 lastcomma",
"semicolonpart :",
"semicolonpart : ';' ffieldlist",
"lastcomma :",
"lastcomma : ','",
"ffieldlist :",
"ffieldlist : ffieldlist1 lastcomma",
"ffieldlist1 : ffield",
"ffieldlist1 : ffieldlist1 ',' ffield",
"ffield : NAME '=' expr1",
"lfieldlist :",
"lfieldlist : lfieldlist1 lastcomma",
"lfieldlist1 : expr1",
"lfieldlist1 : lfieldlist1 ',' expr1",
"varlist1 : var",
"varlist1 : varlist1 ',' var",
"var : singlevar",
"var : varexp '[' expr1 ']'",
"var : varexp '.' NAME",
"singlevar : NAME",
"varexp : var",
"localdeclist : NAME",
"localdeclist : localdeclist ',' NAME",
"decinit :",
"decinit : '=' exprlist1",

};
#endif
/* define the initial stack-sizes */
#ifdef YYSTACKSIZE
#undef YYMAXDEPTH
#define YYMAXDEPTH  YYSTACKSIZE
#else
#ifdef YYMAXDEPTH
#define YYSTACKSIZE YYMAXDEPTH
#else
#define YYSTACKSIZE 500
#define YYMAXDEPTH  500
#endif
#endif

#define YYINITSTACKSIZE 500

int      luaY_debug;
int      luaY_nerrs;

typedef struct {
    unsigned stacksize;
    short    *s_base;
    short    *s_mark;
    short    *s_last;
    YYSTYPE  *l_base;
    YYSTYPE  *l_mark;
} YYSTACKDATA;
int      luaY_errflag;
int      luaY_char;
YYSTYPE  luaY_val;
YYSTYPE  luaY_lval;

/* variables for the parser stack */
static YYSTACKDATA luaY_stack;

#if YYDEBUG
#include <stdio.h>		/* needed for printf */
#endif

#include <stdlib.h>	/* needed for malloc, etc */
#include <string.h>	/* needed for memset */

/* allocate initial stack or double stack size, up to YYMAXDEPTH */
static int luaY_growstack(YYSTACKDATA *data)
{
    int i;
    unsigned newsize;
    short *newss;
    YYSTYPE *newvs;

    if ((newsize = data->stacksize) == 0)
        newsize = YYINITSTACKSIZE;
    else if (newsize >= YYMAXDEPTH)
        return -1;
    else if ((newsize *= 2) > YYMAXDEPTH)
        newsize = YYMAXDEPTH;

    i = data->s_mark - data->s_base;
    newss = (data->s_base != 0)
          ? (short *)realloc(data->s_base, newsize * sizeof(*newss))
          : (short *)malloc(newsize * sizeof(*newss));
    if (newss == 0)
        return -1;

    data->s_base = newss;
    data->s_mark = newss + i;

    newvs = (data->l_base != 0)
          ? (YYSTYPE *)realloc(data->l_base, newsize * sizeof(*newvs))
          : (YYSTYPE *)malloc(newsize * sizeof(*newvs));
    if (newvs == 0)
        return -1;

    data->l_base = newvs;
    data->l_mark = newvs + i;

    data->stacksize = newsize;
    data->s_last = data->s_base + newsize - 1;
    return 0;
}

#if YYPURE || defined(YY_NO_LEAKS)
static void luaY_freestack(YYSTACKDATA *data)
{
    free(data->s_base);
    free(data->l_base);
    memset(data, 0, sizeof(*data));
}
#else
#define luaY_freestack(data) /* nothing */
#endif

#define YYABORT  goto luaY_abort
#define YYREJECT goto luaY_abort
#define YYACCEPT goto luaY_accept
#define YYERROR  goto luaY_errlab

int
YYPARSE_DECL()
{
    int luaY_m, luaY_n, luaY_state;
#if YYDEBUG
    const char *luaY_s;

    if ((luaY_s = getenv("YYDEBUG")) != 0)
    {
        luaY_n = *luaY_s;
        if (luaY_n >= '0' && luaY_n <= '9')
            luaY_debug = luaY_n - '0';
    }
#endif

    luaY_nerrs = 0;
    luaY_errflag = 0;
    luaY_char = YYEMPTY;
    luaY_state = 0;

#if YYPURE
    memset(&luaY_stack, 0, sizeof(luaY_stack));
#endif

    if (luaY_stack.s_base == NULL && luaY_growstack(&luaY_stack)) goto luaY_overflow;
    luaY_stack.s_mark = luaY_stack.s_base;
    luaY_stack.l_mark = luaY_stack.l_base;
    luaY_state = 0;
    *luaY_stack.s_mark = 0;

luaY_loop:
    if ((luaY_n = luaY_defred[luaY_state]) != 0) goto luaY_reduce;
    if (luaY_char < 0)
    {
        if ((luaY_char = YYLEX) < 0) luaY_char = 0;
#if YYDEBUG
        if (luaY_debug)
        {
            luaY_s = 0;
            if (luaY_char <= YYMAXTOKEN) luaY_s = luaY_name[luaY_char];
            if (!luaY_s) luaY_s = "illegal-symbol";
            printf("%sdebug: state %d, reading %d (%s)\n",
                    YYPREFIX, luaY_state, luaY_char, luaY_s);
        }
#endif
    }
    if ((luaY_n = luaY_sindex[luaY_state]) && (luaY_n += luaY_char) >= 0 &&
            luaY_n <= YYTABLESIZE && luaY_check[luaY_n] == luaY_char)
    {
#if YYDEBUG
        if (luaY_debug)
            printf("%sdebug: state %d, shifting to state %d\n",
                    YYPREFIX, luaY_state, luaY_table[luaY_n]);
#endif
        if (luaY_stack.s_mark >= luaY_stack.s_last && luaY_growstack(&luaY_stack))
        {
            goto luaY_overflow;
        }
        luaY_state = luaY_table[luaY_n];
        *++luaY_stack.s_mark = luaY_table[luaY_n];
        *++luaY_stack.l_mark = luaY_lval;
        luaY_char = YYEMPTY;
        if (luaY_errflag > 0)  --luaY_errflag;
        goto luaY_loop;
    }
    if ((luaY_n = luaY_rindex[luaY_state]) && (luaY_n += luaY_char) >= 0 &&
            luaY_n <= YYTABLESIZE && luaY_check[luaY_n] == luaY_char)
    {
        luaY_n = luaY_table[luaY_n];
        goto luaY_reduce;
    }
    if (luaY_errflag) goto luaY_inrecovery;

    luaY_error("syntax error");

    goto luaY_errlab;

luaY_errlab:
    ++luaY_nerrs;

luaY_inrecovery:
    if (luaY_errflag < 3)
    {
        luaY_errflag = 3;
        for (;;)
        {
            if ((luaY_n = luaY_sindex[*luaY_stack.s_mark]) && (luaY_n += YYERRCODE) >= 0 &&
                    luaY_n <= YYTABLESIZE && luaY_check[luaY_n] == YYERRCODE)
            {
#if YYDEBUG
                if (luaY_debug)
                    printf("%sdebug: state %d, error recovery shifting\
 to state %d\n", YYPREFIX, *luaY_stack.s_mark, luaY_table[luaY_n]);
#endif
                if (luaY_stack.s_mark >= luaY_stack.s_last && luaY_growstack(&luaY_stack))
                {
                    goto luaY_overflow;
                }
                luaY_state = luaY_table[luaY_n];
                *++luaY_stack.s_mark = luaY_table[luaY_n];
                *++luaY_stack.l_mark = luaY_lval;
                goto luaY_loop;
            }
            else
            {
#if YYDEBUG
                if (luaY_debug)
                    printf("%sdebug: error recovery discarding state %d\n",
                            YYPREFIX, *luaY_stack.s_mark);
#endif
                if (luaY_stack.s_mark <= luaY_stack.s_base) goto luaY_abort;
                --luaY_stack.s_mark;
                --luaY_stack.l_mark;
            }
        }
    }
    else
    {
        if (luaY_char == 0) goto luaY_abort;
#if YYDEBUG
        if (luaY_debug)
        {
            luaY_s = 0;
            if (luaY_char <= YYMAXTOKEN) luaY_s = luaY_name[luaY_char];
            if (!luaY_s) luaY_s = "illegal-symbol";
            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
                    YYPREFIX, luaY_state, luaY_char, luaY_s);
        }
#endif
        luaY_char = YYEMPTY;
        goto luaY_loop;
    }

luaY_reduce:
#if YYDEBUG
    if (luaY_debug)
        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
                YYPREFIX, luaY_state, luaY_n, luaY_rule[luaY_n]);
#endif
    luaY_m = luaY_len[luaY_n];
    if (luaY_m)
        luaY_val = luaY_stack.l_mark[1-luaY_m];
    else
        memset(&luaY_val, 0, sizeof luaY_val);
    switch (luaY_n)
    {
case 5:
#line 493 "lua.stx"
	{ 
		code_byte(PUSHFUNCTION);
		code_code(luaY_stack.l_mark[0].pFunc);
		storesinglevar(luaY_stack.l_mark[-1].vLong);
	       }
break;
case 6:
#line 500 "lua.stx"
	{ luaY_val.vLong =luaY_stack.l_mark[0].vLong; init_func(); }
break;
case 7:
#line 502 "lua.stx"
	{
	  code_byte(PUSHSTRING);
	  code_word(luaI_findconstant(luaY_stack.l_mark[0].pTStr));
	  luaY_val.vLong = 0;  /* indexed variable */
	  init_func();
	  add_localvar(luaI_createfixedstring("self"));
	}
break;
case 8:
#line 512 "lua.stx"
	{
          codereturn();
	  luaY_val.pFunc = new(TFunc);
          luaI_initTFunc(luaY_val.pFunc);
	  luaY_val.pFunc->size = pc;
	  luaY_val.pFunc->code = newvector(pc, Byte);
	  luaY_val.pFunc->fileName = lua_parsedfile;
	  luaY_val.pFunc->lineDefined = luaY_stack.l_mark[-3].vInt;
	  memcpy(luaY_val.pFunc->code, basepc, pc*sizeof(Byte));
          if (lua_debug)
            luaI_closelocalvars(luaY_val.pFunc);
	  /* save func values */
	  funcCode = basepc; maxcode=maxcurr;
#if LISTING
                PrintCode(funcCode,funcCode+pc);
#endif
	  change2main();  /* change back to main code */
	}
break;
case 13:
#line 539 "lua.stx"
	{ codeIf(luaY_stack.l_mark[-4].vLong, luaY_stack.l_mark[-2].vLong); }
break;
case 16:
#line 545 "lua.stx"
	{luaY_val.vLong=pc;}
break;
case 17:
#line 546 "lua.stx"
	{
        basepc[luaY_stack.l_mark[-3].vLong] = IFFJMP;
	code_word_at(basepc+luaY_stack.l_mark[-3].vLong+1, pc - (luaY_stack.l_mark[-3].vLong + sizeof(Word)+1));
        basepc[luaY_stack.l_mark[-1].vLong] = UPJMP;
	code_word_at(basepc+luaY_stack.l_mark[-1].vLong+1, pc - (luaY_stack.l_mark[-6].vLong));
       }
break;
case 18:
#line 553 "lua.stx"
	{luaY_val.vLong=pc;}
break;
case 19:
#line 554 "lua.stx"
	{
        basepc[luaY_stack.l_mark[0].vLong] = IFFUPJMP;
	code_word_at(basepc+luaY_stack.l_mark[0].vLong+1, pc - (luaY_stack.l_mark[-4].vLong));
       }
break;
case 20:
#line 560 "lua.stx"
	{
        {
         int i;
         adjust_mult_assign(nvarbuffer, luaY_stack.l_mark[0].vLong, luaY_stack.l_mark[-2].vInt * 2 + nvarbuffer);
	 for (i=nvarbuffer-1; i>=0; i--)
	  lua_codestore (i);
	 if (luaY_stack.l_mark[-2].vInt > 1 || (luaY_stack.l_mark[-2].vInt == 1 && varbuffer[0] != 0))
	  lua_codeadjust (0);
	}
       }
break;
case 22:
#line 572 "lua.stx"
	{ nlocalvar += luaY_stack.l_mark[-1].vInt;
	  adjust_mult_assign(luaY_stack.l_mark[-1].vInt, luaY_stack.l_mark[0].vInt, 0);
	}
break;
case 25:
#line 580 "lua.stx"
	{ codeIf(luaY_stack.l_mark[-3].vLong, luaY_stack.l_mark[-1].vLong); }
break;
case 26:
#line 585 "lua.stx"
	{code_byte(DUP);}
break;
case 28:
#line 586 "lua.stx"
	{code_byte(POP);}
break;
case 30:
#line 587 "lua.stx"
	{code_byte(POP); /* should code for fallback here */ }
break;
case 31:
#line 592 "lua.stx"
	{code_byte(DUP);}
break;
case 32:
#line 593 "lua.stx"
	{codeIfEqJmp(luaY_stack.l_mark[-3].vLong,luaY_stack.l_mark[0].vLong); luaY_val.vLong=luaY_stack.l_mark[0].vLong;}
break;
case 33:
#line 594 "lua.stx"
	{code_byte(EQOP);}
break;
case 34:
#line 595 "lua.stx"
	{code_byte(POP);}
break;
case 35:
#line 598 "lua.stx"
	{codeIf(luaY_stack.l_mark[-5].vLong,luaY_stack.l_mark[-1].vLong);luaY_val.vLong=luaY_stack.l_mark[-5].vLong+3;}
break;
case 36:
#line 603 "lua.stx"
	{code_byte(DUP);}
break;
case 38:
#line 604 "lua.stx"
	{code_byte(POP);}
break;
case 40:
#line 605 "lua.stx"
	{code_byte(POP); /* should code for fallback here */ }
break;
case 41:
#line 610 "lua.stx"
	{code_byte(DUP);}
break;
case 42:
#line 611 "lua.stx"
	{codeIfEqJmp(luaY_stack.l_mark[-3].vLong,luaY_stack.l_mark[0].vLong); luaY_val.vLong=luaY_stack.l_mark[0].vLong;}
break;
case 43:
#line 612 "lua.stx"
	{code_byte(GLOBMATCHOP);}
break;
case 44:
#line 613 "lua.stx"
	{code_byte(POP);}
break;
case 45:
#line 616 "lua.stx"
	{codeIf(luaY_stack.l_mark[-5].vLong,luaY_stack.l_mark[-1].vLong);luaY_val.vLong=luaY_stack.l_mark[-5].vLong+3;}
break;
case 46:
#line 619 "lua.stx"
	{luaY_val.vInt = nlocalvar;}
break;
case 47:
#line 620 "lua.stx"
	{
	  if (nlocalvar != luaY_stack.l_mark[-2].vInt)
	  {
           if (lua_debug)
             for (; nlocalvar > luaY_stack.l_mark[-2].vInt; nlocalvar--)
               luaI_unregisterlocalvar(lua_linenumber);
           else
             nlocalvar = luaY_stack.l_mark[-2].vInt;
	   lua_codeadjust (0);
	  }
         }
break;
case 49:
#line 635 "lua.stx"
	{
	   adjust_functioncall(luaY_stack.l_mark[-1].vLong, MULT_RET);
           codereturn();
          }
break;
case 50:
#line 642 "lua.stx"
	{ 
	  luaY_val.vLong = pc;
	  code_byte(0);		/* open space */
	  code_word (0);
         }
break;
case 51:
#line 650 "lua.stx"
	{ code_byte(EQOP); code_byte(NOTOP); code_byte(IFFJMP); 
               luaY_val.vLong = pc; code_word(0);
             }
break;
case 52:
#line 656 "lua.stx"
	{ code_byte(GLOBMATCHOP); code_byte(NOTOP); code_byte(IFFJMP); 
               luaY_val.vLong = pc; code_word(0);
             }
break;
case 53:
#line 661 "lua.stx"
	{ adjust_functioncall(luaY_stack.l_mark[0].vLong, 1); }
break;
case 54:
#line 664 "lua.stx"
	{ luaY_val.vLong = luaY_stack.l_mark[-1].vLong; }
break;
case 55:
#line 665 "lua.stx"
	{ code_byte(EQOP);   luaY_val.vLong = 0; }
break;
case 56:
#line 666 "lua.stx"
	{ code_byte(LTOP);   luaY_val.vLong = 0; }
break;
case 57:
#line 667 "lua.stx"
	{ code_byte(GTOP);   luaY_val.vLong = 0; }
break;
case 58:
#line 668 "lua.stx"
	{ code_byte(EQOP); code_byte(NOTOP); luaY_val.vLong = 0; }
break;
case 59:
#line 669 "lua.stx"
	{ code_byte(LEOP);   luaY_val.vLong = 0; }
break;
case 60:
#line 670 "lua.stx"
	{ code_byte(GEOP);   luaY_val.vLong = 0; }
break;
case 61:
#line 671 "lua.stx"
	{ code_byte(ADDOP);  luaY_val.vLong = 0; }
break;
case 62:
#line 672 "lua.stx"
	{ code_byte(SUBOP);  luaY_val.vLong = 0; }
break;
case 63:
#line 673 "lua.stx"
	{ code_byte(MULTOP); luaY_val.vLong = 0; }
break;
case 64:
#line 674 "lua.stx"
	{ code_byte(DIVOP);  luaY_val.vLong = 0; }
break;
case 65:
#line 675 "lua.stx"
	{ code_byte(POWOP);  luaY_val.vLong = 0; }
break;
case 66:
#line 676 "lua.stx"
	{ code_byte(CONCOP);  luaY_val.vLong = 0; }
break;
case 67:
#line 677 "lua.stx"
	{ code_byte(MINUSOP); luaY_val.vLong = 0;}
break;
case 68:
#line 678 "lua.stx"
	{ luaY_val.vLong = 0; }
break;
case 69:
#line 679 "lua.stx"
	{ luaY_val.vLong = 0;}
break;
case 70:
#line 680 "lua.stx"
	{ code_number(luaY_stack.l_mark[0].vFloat); luaY_val.vLong = 0; }
break;
case 71:
#line 682 "lua.stx"
	{
      code_byte(PUSHSTRING);
      code_word(luaY_stack.l_mark[0].vWord);
      luaY_val.vLong = 0;
     }
break;
case 72:
#line 687 "lua.stx"
	{code_byte(PUSHNIL); luaY_val.vLong = 0; }
break;
case 73:
#line 688 "lua.stx"
	{ luaY_val.vLong = luaY_stack.l_mark[0].vLong; }
break;
case 74:
#line 689 "lua.stx"
	{ code_byte(NOTOP);  luaY_val.vLong = 0;}
break;
case 75:
#line 690 "lua.stx"
	{code_byte(POP); }
break;
case 76:
#line 691 "lua.stx"
	{ 
      basepc[luaY_stack.l_mark[-2].vLong] = ONFJMP;
      code_word_at(basepc+luaY_stack.l_mark[-2].vLong+1, pc - (luaY_stack.l_mark[-2].vLong + sizeof(Word)+1));
      luaY_val.vLong = 0;
     }
break;
case 77:
#line 696 "lua.stx"
	{code_byte(POP); }
break;
case 78:
#line 697 "lua.stx"
	{ 
      basepc[luaY_stack.l_mark[-2].vLong] = ONTJMP;
      code_word_at(basepc+luaY_stack.l_mark[-2].vLong+1, pc - (luaY_stack.l_mark[-2].vLong + sizeof(Word)+1));
      luaY_val.vLong = 0;
     }
break;
case 79:
#line 705 "lua.stx"
	{
      code_byte(CREATEARRAY);
      luaY_val.vLong = pc; code_word(0);
     }
break;
case 80:
#line 710 "lua.stx"
	{
      code_word_at(basepc+luaY_stack.l_mark[-3].vLong, luaY_stack.l_mark[-1].vInt);
     }
break;
case 81:
#line 716 "lua.stx"
	{
	  code_byte(CALLFUNC);
	  code_byte(luaY_stack.l_mark[-1].vInt+luaY_stack.l_mark[0].vInt);
	  luaY_val.vLong = pc;
	  code_byte(0);  /* may be modified by other rules */
	}
break;
case 82:
#line 724 "lua.stx"
	{ luaY_val.vInt = 0; }
break;
case 83:
#line 726 "lua.stx"
	{ 
               code_byte(PUSHSELF); 
	       code_word(luaI_findconstant(luaY_stack.l_mark[0].pTStr));
               luaY_val.vInt = 1;
	     }
break;
case 84:
#line 734 "lua.stx"
	{ luaY_val.vInt = adjust_functioncall(luaY_stack.l_mark[-1].vLong, 1); }
break;
case 85:
#line 735 "lua.stx"
	{ luaY_val.vInt = 1; }
break;
case 86:
#line 738 "lua.stx"
	{ luaY_val.vLong = 0; }
break;
case 87:
#line 739 "lua.stx"
	{ luaY_val.vLong = luaY_stack.l_mark[0].vLong; }
break;
case 88:
#line 742 "lua.stx"
	{ if (luaY_stack.l_mark[0].vLong != 0) luaY_val.vLong = luaY_stack.l_mark[0].vLong; else luaY_val.vLong = -1; }
break;
case 89:
#line 743 "lua.stx"
	{ luaY_val.vLong = adjust_functioncall(luaY_stack.l_mark[-1].vLong, 1); }
break;
case 90:
#line 744 "lua.stx"
	{
	  if (luaY_stack.l_mark[0].vLong == 0) luaY_val.vLong = -(luaY_stack.l_mark[-1].vLong + 1);  /* -length */
	  else
	  {
	    adjust_functioncall(luaY_stack.l_mark[0].vLong, luaY_stack.l_mark[-1].vLong);
	    luaY_val.vLong = luaY_stack.l_mark[0].vLong;
	  }
	}
break;
case 91:
#line 754 "lua.stx"
	{ luaY_val.vInt = close_parlist(0); }
break;
case 92:
#line 755 "lua.stx"
	{ luaY_val.vInt = close_parlist(luaY_stack.l_mark[0].vInt); }
break;
case 93:
#line 758 "lua.stx"
	{ luaY_val.vInt = luaY_stack.l_mark[0].vInt; }
break;
case 94:
#line 760 "lua.stx"
	{
	  if (luaY_stack.l_mark[-2].vInt)
            lua_error("invalid parameter list");
          luaY_val.vInt = luaY_stack.l_mark[0].vInt;
	}
break;
case 95:
#line 767 "lua.stx"
	{ add_localvar(luaY_stack.l_mark[0].pTStr); luaY_val.vInt = 0; }
break;
case 96:
#line 768 "lua.stx"
	{ luaY_val.vInt = 1; }
break;
case 97:
#line 772 "lua.stx"
	{ flush_list(luaY_stack.l_mark[0].vInt/FIELDS_PER_FLUSH, luaY_stack.l_mark[0].vInt%FIELDS_PER_FLUSH); }
break;
case 98:
#line 774 "lua.stx"
	{ luaY_val.vInt = luaY_stack.l_mark[-2].vInt+luaY_stack.l_mark[0].vInt; }
break;
case 99:
#line 776 "lua.stx"
	{ luaY_val.vInt = luaY_stack.l_mark[-1].vInt; flush_record(luaY_stack.l_mark[-1].vInt%FIELDS_PER_FLUSH); }
break;
case 100:
#line 780 "lua.stx"
	{ luaY_val.vInt = 0; }
break;
case 101:
#line 782 "lua.stx"
	{ luaY_val.vInt = luaY_stack.l_mark[0].vInt; flush_record(luaY_stack.l_mark[0].vInt%FIELDS_PER_FLUSH); }
break;
case 104:
#line 789 "lua.stx"
	{ luaY_val.vInt = 0; }
break;
case 105:
#line 790 "lua.stx"
	{ luaY_val.vInt = luaY_stack.l_mark[-1].vInt; }
break;
case 106:
#line 793 "lua.stx"
	{luaY_val.vInt=1;}
break;
case 107:
#line 795 "lua.stx"
	{
		  luaY_val.vInt=luaY_stack.l_mark[-2].vInt+1;
		  if (luaY_val.vInt%FIELDS_PER_FLUSH == 0) flush_record(FIELDS_PER_FLUSH);
		}
break;
case 108:
#line 802 "lua.stx"
	{ 
	       push_field(luaI_findconstant(luaY_stack.l_mark[-2].pTStr));
	      }
break;
case 109:
#line 807 "lua.stx"
	{ luaY_val.vInt = 0; }
break;
case 110:
#line 808 "lua.stx"
	{ luaY_val.vInt = luaY_stack.l_mark[-1].vInt; }
break;
case 111:
#line 811 "lua.stx"
	{luaY_val.vInt=1;}
break;
case 112:
#line 813 "lua.stx"
	{
		  luaY_val.vInt=luaY_stack.l_mark[-2].vInt+1;
		  if (luaY_val.vInt%FIELDS_PER_FLUSH == 0) 
		    flush_list(luaY_val.vInt/FIELDS_PER_FLUSH - 1, FIELDS_PER_FLUSH);
		}
break;
case 113:
#line 821 "lua.stx"
	{
	   nvarbuffer = 0; 
	   add_varbuffer(luaY_stack.l_mark[0].vLong);
	   luaY_val.vInt = (luaY_stack.l_mark[0].vLong == 0) ? 1 : 0;
	  }
break;
case 114:
#line 827 "lua.stx"
	{ 
	   add_varbuffer(luaY_stack.l_mark[0].vLong);
	   luaY_val.vInt = (luaY_stack.l_mark[0].vLong == 0) ? luaY_stack.l_mark[-2].vInt + 1 : luaY_stack.l_mark[-2].vInt;
	  }
break;
case 115:
#line 833 "lua.stx"
	{ luaY_val.vLong = luaY_stack.l_mark[0].vLong; }
break;
case 116:
#line 835 "lua.stx"
	{
	   luaY_val.vLong = 0;		/* indexed variable */
	  }
break;
case 117:
#line 839 "lua.stx"
	{
	   code_byte(PUSHSTRING);
	   code_word(luaI_findconstant(luaY_stack.l_mark[0].pTStr));
	   luaY_val.vLong = 0;		/* indexed variable */
	  }
break;
case 118:
#line 847 "lua.stx"
	{
	   int local = lua_localname(luaY_stack.l_mark[0].pTStr);
	   if (local == -1)	/* global var */
	    luaY_val.vLong = luaI_findsymbol(luaY_stack.l_mark[0].pTStr)+1;  /* return positive value */
           else
	    luaY_val.vLong = -(local+1);		/* return negative value */
	  }
break;
case 119:
#line 856 "lua.stx"
	{ lua_pushvar(luaY_stack.l_mark[0].vLong); }
break;
case 120:
#line 859 "lua.stx"
	{store_localvar(luaY_stack.l_mark[0].pTStr, 0); luaY_val.vInt = 1;}
break;
case 121:
#line 861 "lua.stx"
	{
	     store_localvar(luaY_stack.l_mark[0].pTStr, luaY_stack.l_mark[-2].vInt);
	     luaY_val.vInt = luaY_stack.l_mark[-2].vInt+1;
	    }
break;
case 122:
#line 867 "lua.stx"
	{ luaY_val.vInt = 0; }
break;
case 123:
#line 868 "lua.stx"
	{ luaY_val.vInt = luaY_stack.l_mark[0].vLong; }
break;
#line 1937 "y.tab.c"
    }
    luaY_stack.s_mark -= luaY_m;
    luaY_state = *luaY_stack.s_mark;
    luaY_stack.l_mark -= luaY_m;
    luaY_m = luaY_lhs[luaY_n];
    if (luaY_state == 0 && luaY_m == 0)
    {
#if YYDEBUG
        if (luaY_debug)
            printf("%sdebug: after reduction, shifting from state 0 to\
 state %d\n", YYPREFIX, YYFINAL);
#endif
        luaY_state = YYFINAL;
        *++luaY_stack.s_mark = YYFINAL;
        *++luaY_stack.l_mark = luaY_val;
        if (luaY_char < 0)
        {
            if ((luaY_char = YYLEX) < 0) luaY_char = 0;
#if YYDEBUG
            if (luaY_debug)
            {
                luaY_s = 0;
                if (luaY_char <= YYMAXTOKEN) luaY_s = luaY_name[luaY_char];
                if (!luaY_s) luaY_s = "illegal-symbol";
                printf("%sdebug: state %d, reading %d (%s)\n",
                        YYPREFIX, YYFINAL, luaY_char, luaY_s);
            }
#endif
        }
        if (luaY_char == 0) goto luaY_accept;
        goto luaY_loop;
    }
    if ((luaY_n = luaY_gindex[luaY_m]) && (luaY_n += luaY_state) >= 0 &&
            luaY_n <= YYTABLESIZE && luaY_check[luaY_n] == luaY_state)
        luaY_state = luaY_table[luaY_n];
    else
        luaY_state = luaY_dgoto[luaY_m];
#if YYDEBUG
    if (luaY_debug)
        printf("%sdebug: after reduction, shifting from state %d \
to state %d\n", YYPREFIX, *luaY_stack.s_mark, luaY_state);
#endif
    if (luaY_stack.s_mark >= luaY_stack.s_last && luaY_growstack(&luaY_stack))
    {
        goto luaY_overflow;
    }
    *++luaY_stack.s_mark = (short) luaY_state;
    *++luaY_stack.l_mark = luaY_val;
    goto luaY_loop;

luaY_overflow:
    luaY_error("yacc stack overflow");

luaY_abort:
    luaY_freestack(&luaY_stack);
    return (1);

luaY_accept:
    luaY_freestack(&luaY_stack);
    return (0);
}
